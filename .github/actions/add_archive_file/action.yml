add_archive_file:
name: 'Add file to tar archive'
description: |
  Add a file to a tar archive.
  Does not need to have any file extension.
  Works on archives with gzip compression.
inputs:
  archive-path:
    description: 'Path of the tar archive.'
    required: true
  is-gzip-compressed:
    description: 'Whether the tar archive is compressed.'
    required: true
  file-path:
    description: 'Path of the file to add to the tar archive.'
    required: true
  archive-hierarchy-location:
    description: 'Path of the file inside of the tar archive, once it has been inserted.'
    required: true
outputs:
  result_archive_path:
    description: 'The path, including name, to the archive.'
    value: ${{ inputs.archive-path }}
runs:
  using: "composite"
  steps:
  - name: Collect some info now so we can perform asserts at the end
    id: pre-assert
    shell: bash
    run: |
      ## Collect some info now so we can perform asserts at the end

      # calculate archive_size
      archive_size="$(du --block-size=1K $archive_path | cut -f1)"
      echo "archive_size=$archive_size" >> $GITHUB_OUTPUT

      # calculate additions_size
      additions_size="$(du --block-size=1K $file_additions | cut -f1)"
      echo "additions_size=$additions_size" >> $GITHUB_OUTPUT
    env:
      archive_path: ${{ inputs.archive-path }}
      file_additions: ${{ inputs.file-path }}
    # outputs:
    # archive_size: Size of original archive, divided by 1024 bytes, no K suffix.
    # additions_size: Total size of files to add, divided by 1024 bytes, no K suffix.

  - name: Make a working directory available, format archive-hierarchy-location
    id: safe-paths
    shell: bash
    run: |
      ## Make a working directory available, format archive-hierarchy-location

      # $working_dir
      [[ "${working_dir}" != */ ]] && working_dir="${working_dir}/" # ensure path string ends with slash
      working_dir=${working_dir/\~/$HOME}                           # replace '~' with home directory (can't figure out how to get this to happen automatically)
      mkdir -p $working_dir                                         # ensure path exists
      echo "working_dir=$working_dir" >> $GITHUB_OUTPUT             # output

      # $archive_location
      [[ "${archive_location}" != */ ]] && archive_location="${archive_location}/"  # ensure path string ends with slash
      echo "in_archive_location=$archive_location" >> $GITHUB_OUTPUT                # output
    env:
      working_dir: ~/add_archive_file_working_dir/
      archive_location: ${{ inputs.archive-hierarchy-location }}
    # outputs:
    # working_dir: Location of the working directory, which exists, ending with a slash.
    # in_archive_location: archive-hierarchy-location, ending with exactly one slash.

  - name: Unzip the archive
    id: unzip-archive
    if: ${{ inputs.is-gzip-compressed }}
    shell: bash
    run: |
      ## Unzip the archive

      # Form a regex to capture a file path's parent directory path
      # (match from beginning to the last '/' that is not escaped by a '\')
      # match_directory_pattern="^\(.*\[^\\\]\)\?\/"    # non-extended regex version
      match_directory_pattern='^(.*[^\\])?\/'           # extended regex version

      # Form the destination path where we unzip to (does not change filename)
      decompressed_path="${gzipped_path/$match_directory_pattern/$working_directory}"

      # Debug output: location we will unzip to
      echo "Decompressing to: $decompressed_path"
      if [ -e "$decompressed_path" ]; then
        echo "Note: file already exists at this path, replacing it."
      fi

      # Unzip to the temp location
      cat $gzipped_path | gzip -d > $decompressed_path
      
      # Debug output: show size and location
      ls -lh $decompressed_path

      # Provide our result archive location
      echo "decompressed_path=$decompressed_path" >> $GITHUB_OUTPUT
    env:
      gzipped_path: ${{ inputs.archive-path }}
      working_directory: ${{ steps.safe-paths.outputs.working_dir }}
    # outputs:
    # decompressed_path: Location of the unzipped archive.

  - name: Provide the unzipped archive path (did we unzip the archive to a new place?)
    id: where-archive
    shell: bash
    run: |
      ## Provide the unzipped archive path (did we unzip the archive to a new place?)

      if [[ "$new_path_was_created" == 'true' ]]; then
        echo "path=$created_path" >> $GITHUB_OUTPUT
      else
        echo "path=$original_path" >> $GITHUB_OUTPUT
      fi
    env:
      new_path_was_created: ${{ inputs.is-gzip-compressed }}
      original_path: ${{ inputs.archive-path }}
      created_path: ${{ steps.unzip-archive.outputs.decompressed_path }}
    # outputs:
    # path: Location of the unzipped archive (always available, unlike unzip-archive).
    
  - name: Add the file to the archive
    shell: bash
    run: |
      ## Add the file to the archive

      # match from beginning to the last '/' not preceded by a '\'
      # PATTERN="^\(.*\[^\\\]\)\?\/" # non-extended regex version
      PATTERN='^(.*[^\\])?\/' # extended regex version

      # replace with destination directory
      REPLACEMENT="${INSERT_DIR//[&\/\\]/\\&}" # escape all characters that are special for a replacement string

      SED_EXPRESSION="s/$PATTERN/$REPLACEMENT/"
      tar --append -vf $amd64_d_archive --transform "$SED_EXPRESSION" "$SOURCE_FILE"
    env:
      SOURCE_FILE: ${{ inputs.file-path }}
      INSERT_DIR: ${{ steps.safe-paths.outputs.in_archive_location }} # directory within the archive's filesystem
      non_gzip_archive: ${{ steps.where-archive.outputs.path }}

  - name: Rezip the archive, return to original location
    if: ${{ inputs.is-gzip-compressed }}
    id: rezip-archive
    shell: bash
    run: |
      ## Rezip the archive, return to original location
      cat $decompressed_path | gzip > $original_archive_path
    env:
      original_archive_path: ${{ inputs.archive-path }}
      decompressed_path: ${{ steps.unzip-archive.outputs.decompressed_path }}

  - name: Assert we changed the size of our archive
    if: always()
    shell: bash
    run: |
      ## Assert we changed the size of our archive
      echo "Note: if archive is gzipped, size increase of archive may be smaller than size of added file."
      final_archive_size_1K="$(du --block-size=1K $archive_path | cut -f1)"
      echo "Size of original archive: ${original_archive_size_1K} K"
      echo "Size of added file: ${expected_size_increase_1K} K"
      echo "New archive size: ${final_archive_size_1K} K"

      if [ "$final_archive_size_1K" -le "$original_archive_size_1K" ]; then
        echo "Assertion failed: new archive is not larger than old archive" >&2
        exit 1
      fi
    env:
      # make sure these were calculated with --block-size=1K.
      original_archive_size_1K: ${{ steps.pre-assert.outputs.archive_size }}
      expected_size_increase_1K: ${{ steps.pre-assert.outputs.additions_size }}
      # make sure this matches the expression which defines the action's output.
      archive_path: ${{ inputs.archive-path }}
