add_archive_file:
name: 'Add file to tar archive'
description: |
  Add a file to a tar archive.
  Does not need to have any file extension.
  Works on archives with gzip compression.
inputs:
  archive-path:
    description: 'Path of the tar archive.'
    required: true
  is-gzip-compressed:
    description: 'Whether the tar archive is compressed.'
    required: true
  file-path:
    description: 'Path of the file to add to the tar archive.'
    required: true
  archive-hierarchy-location:
    description: 'Path of the file inside of the tar archive, once it has been inserted.'
    required: true
outputs:
  result_archive_path:
    description: 'The path, including name, to the archive.'
    value: ${{ inputs.archive-path }}
runs:
  using: "composite"
  steps:
  - name: Collect some info now so we can perform asserts at the end
    id: pre-assert
    shell: bash
    run:
      ## Collect some info now so we can perform asserts at the end
      archive_size="$(du --block-size=1K $archive_path)"
      echo "archive_size=$archive_size" >> $GITHUB_OUTPUT
      additions_size="$(du --block-size=1K $file_additions)"
      echo "additions_size=$additions_size" >> $GITHUB_OUTPUT
    env:
      archive_path: ${{ inputs.archive-path }}
      file_additions: ${{ inputs.file-path }}
    # outputs:
    # archive_size: Size of original archive, divided by 1024 bytes, no K suffix.
    # additions_size: Total size of files to add, divided by 1024 bytes, no K suffix.

  - name: Make a working directory available, format archive-hierarchy-location
    id: safe-paths
    shell: bash
    run: |
      ## Make a working directory available, format archive-hierarchy-location

      [[ "${working_dir}" != */ ]] && working_dir="${working_dir}/" # ensure $working_dir ends with slash
      working_dir=${working_dir/\~/$HOME}
      mkdir -p $working_dir
      echo "working_dir=$working_dir" >> $GITHUB_OUTPUT

      [[ "${archive_location}" != */ ]] && archive_location="${archive_location}/"
      echo "in_archive_location=$archive_location" >> $GITHUB_OUTPUT
    env:
      working_dir: ~/add_archive_file_working_dir/
      archive_location: ${{ inputs.archive-hierarchy-location }}
    # outputs:
    # working_dir: Location of the working directory, which exists, ending with a slash.
    # in_archive_location: archive-hierarchy-location, ending with exactly one slash.

  - name: Unzip the archive
    id: unzip-archive
    if: ${{ inputs.is-gzip-compressed }}
    shell: bash
    run: |
      ## Unzip the archive

      # Form a regex to capture a file path's parent directory
      # match from beginning to the last '/' not preceded by a '\'
      # PATTERN="^\(.*\[^\\\]\)\?\/" # non-extended regex version
      PATTERN='^(.*[^\\])?\/' # extended regex version

      # Same filename, new location
      unzip_location="${archive/$PATTERN/$directory}"

      # Unzip
      cat $archive | gzip -d > $unzip_location
      
      # Debug output (show size and location)
      ls -lh $unzip_location

      # Provide our result archive location
      echo "decompressed=$unzip_location" >> $GITHUB_OUTPUT
    env:
      archive: ${{ inputs.archive-path }}
      directory: ${{ steps.safe-paths.outputs.working_dir }}
    # outputs:
    # decompressed: Location of the unzipped archive.

  - name: Provide the unzipped archive path
    id: which-archive
    shell: bash
    run: |
      ## Provide the unzipped archive path

      if [[ "$new_path_was_created" == 'true' ]]; then
        echo "path=$created_path" >> $GITHUB_OUTPUT
      else
        echo "path=$original_path" >> $GITHUB_OUTPUT
      fi
    env:
      new_path_was_created: ${{ inputs.is-gzip-compressed }}
      original_path: ${{ inputs.archive-path }}
      created_path: ${{ steps.unzip-archive.outputs.decompressed }}
    # outputs:
    # path: Location of the unzipped archive (always available, unlike unzip-archive).
    
  - name: Add the file to the archive
    shell: bash
    run: |
      ## Add the file to the archive

      # match from beginning to the last '/' not preceded by a '\'
      # PATTERN="^\(.*\[^\\\]\)\?\/" # non-extended regex version
      PATTERN='^(.*[^\\])?\/' # extended regex version

      # replace with destination directory
      REPLACEMENT="${INSERT_DIR//[&\/\\]/\\&}" # escape all characters that are special for a replacement string

      SED_EXPRESSION="s/$PATTERN/$REPLACEMENT/"
      tar --append -vf $amd64_d_archive --transform "$SED_EXPRESSION" "$SOURCE_FILE"
    env:
      SOURCE_FILE: ${{ inputs.file-path }}
      INSERT_DIR: ${{ steps.safe-paths.outputs.in_archive_location }} # directory within the archive's filesystem
      non_gzip_archive: ${{ steps.which-archive.outputs.path }}

  - name: Rezip the archive, return to original location
    if: ${{ inputs.is-gzip-compressed }}
    id: rezip-archive
    shell: bash
    run: |
      ## Rezip the archive, return to original location
      cat $decompressed | gzip > $original_archive_path
    env:
      original_archive_path: ${{ inputs.archive-path }}
      decompressed: ${{ steps.unzip-archive.outputs.decompressed }}

  - name: Assert we changed the size of our archive
    if: always()
    shell: bash
    run: |
      ## Assert we changed the size of our archive
      echo "Note: if archive is gzipped, size increase may be smaller than size of added file."
      echo "Size of original archive: ${original_archive_size_1K} K"
      echo "Size of added file: ${expected_size_increase_1K} K"
      echo "New archive size: $(du -h --block-size=1K $archive_path)"

      if [ "$(du --block-size=1K $archive_path | cut -f1)" -le "$(original_archive_size_1K)" ]; then
        echo "Assertion failed: new archive is not larger than old archive" >&2
        exit 1
      fi
    env:
      # make sure these were calculated with --block-size=1K.
      original_archive_size_1K: ${{ steps.pre-assert.outputs.archive_size }}
      expected_size_increase_1K: ${{ steps.pre-assert.outputs.additions_size }}
      # make sure this matches the expression which defines the action's output.
      archive_path: ${{ inputs.archive-path }}
