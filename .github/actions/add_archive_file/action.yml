add_archive_file:
name: 'Add file to tar archive'
description: |
  Add a file to a tar archive.
  Does not need to have any file extension.
  Works on archives with gzip compression.
inputs:
  archive-path:
    description: 'Path of the tar archive.'
    required: true
  is-gzip-compressed:
    description: 'Whether the tar archive is compressed.'
    required: true
  file-path:
    description: 'Path of the file to add to the tar archive.'
    required: true
  archive-hierarchy-location:
    description: 'Path of the file inside of the tar archive, once it has been inserted.'
    required: true
outputs:
  result_archive_path:
    description: 'The path, including name, to the archive.'
    value: ${{ inputs.archive-path }}
runs:
  using: "composite"
  steps:
  - name: Collect some info now so we can perform asserts at the end
    id: pre-assert
    shell: bash
    run: |
      ## Collect some info now so we can perform asserts at the end

      # calculate archive_size
      archive_size="$(du --block-size=1K $archive_path | cut -f1)"
      echo "archive_size=$archive_size" | tee -a $GITHUB_OUTPUT

      # calculate additions_size
      additions_size="$(du --block-size=1K $file_additions | cut -f1)"
      echo "additions_size=$additions_size" | tee -a $GITHUB_OUTPUT
    env:
      archive_path: ${{ inputs.archive-path }}
      file_additions: ${{ inputs.file-path }}
    # outputs:
    # archive_size: Size of original archive, divided by 1024 bytes, no K suffix.
    # additions_size: Total size of files to add, divided by 1024 bytes, no K suffix.

  - name: Make a working directory available, format input path (archive-hierarchy-location)
    id: safe-paths
    shell: bash
    run: |
      ## Make a working directory available, format input path (archive-hierarchy-location)

      # $working_dir
      [[ "${working_dir}" != */ ]] && working_dir="${working_dir}/" # ensure path string ends with slash
      working_dir=${working_dir/\~/$HOME}                           # replace '~' with home directory (can't figure out how to get this to happen automatically)
      mkdir -p $working_dir                                         # ensure path exists
      echo "working_dir=$working_dir" | tee -a $GITHUB_OUTPUT       # output

      # $archive_location
      [[ "${archive_location}" != */ ]] && archive_location="${archive_location}/"  # ensure path string ends with slash
      echo "in_archive_location=$archive_location" | tee -a $GITHUB_OUTPUT          # output
    env:
      working_dir: ~/add_archive_file_working_dir/
      archive_location: ${{ inputs.archive-hierarchy-location }}
    # outputs:
    # working_dir: Location of the working directory, which exists, ending with a slash.
    # in_archive_location: archive-hierarchy-location, ending with exactly one slash.

  - name: Unzip the archive
    id: unzip-archive
    if: ${{ inputs.is-gzip-compressed }}
    shell: bash
    run: |
      ## Unzip the archive

      # Form a regex to capture a file path's parent directory path
      # (match from beginning to the last '/' that is not escaped by a '\')
      # match_directory_pattern='^\(.*\[^\\\]\)\?\/'    # non-extended regex version
      match_directory_pattern='^(.*[^\\])?\/'           # extended regex version

      # Form the destination path where we unzip to (does not change filename)
      decompressed_path="${gzipped_path/$match_directory_pattern/$working_directory}"

      # Debug output: location we will unzip to.
      echo "Decompressing to: $decompressed_path"

      # Perform some checks
      if [[ "$gzipped_path" == "$decompressed_path" ]]; then
        echo "Assertion failed: we are decompressing to the same path as we are reading from." >&2
        return 1
      elif [ -e "$decompressed_path" ]; then
        echo "Warning: file already exists at this path, replacing it."
      fi

      # Unzip to the temp location
      cat $gzipped_path | gzip -d > $decompressed_path
      
      # Debug output: show size and location
      ls -lh $decompressed_path

      # Provide our result archive location
      echo "decompressed_path=$decompressed_path" | tee -a $GITHUB_OUTPUT
    env:
      gzipped_path: ${{ inputs.archive-path }}
      working_directory: ${{ steps.safe-paths.outputs.working_dir }}
    # outputs:
    # decompressed_path: Location of the unzipped archive.

  - name: Provide the unzipped archive path (did we unzip the archive to a new place?)
    id: where-archive
    shell: bash
    run: |
      ## Provide the unzipped archive path (did we unzip the archive to a new place?)
      if [[ "$new_path_was_created" == 'true' ]]; then
        echo "path=$created_path" | tee -a $GITHUB_OUTPUT
      else
        echo "path=$original_path" | tee -a $GITHUB_OUTPUT
      fi
    env:
      new_path_was_created: ${{ inputs.is-gzip-compressed }}
      original_path: ${{ inputs.archive-path }}
      created_path: ${{ steps.unzip-archive.outputs.decompressed_path }}
    # outputs:
    # path: Location of the unzipped archive (always available, unlike unzip-archive).
    
  - name: Add the file to the archive
    shell: bash
    run: |
      ## Add the file to the archive

      # Form an expression telling tar to add the file at $directory_in_archive,
      # not the directory in the GitHub Actions runner's filesystem

      # match:
      # from beginning to the last '/' not preceded by a '\'
      # match_directory_pattern='^\(.*\[^\\\]\)\?\/'  # non-extended regex version
      match_directory_pattern='^(.*[^\\])?\/'         # extended regex version
      echo "match_directory_pattern: $match_directory_pattern"

      # replace with:
      # escape all characters that would be special when present in the second part of a sed expression: &, /, \
      # using a preceding backslash: \
      directory_escaped_for_sed="${directory_in_archive//[&\/\\]/\\&}"
      echo "directory_escaped_for_sed: $directory_escaped_for_sed"

      sed_expression="s/$match_directory_pattern/$directory_escaped_for_sed/"
      echo "sed_expression: $sed_expression"

      # Perform checks on our regex work
      inputs=(
        '/test/directory/file'
        'test/direction/file'
        'file'
        '/'
      )
      expecteds=(
        '${directory_in_archive}file'
        '${directory_in_archive}file'
        'file'
        '${directory_in_archive}'
      )
      for i in {0..3}; do
        echo "Testing input case #${i}:"
        echo "${inputs[i]}"

        output="${inputs[i]}"
        if [[ "$output" != "${expecteds[i]}" ]]; then
          echo "Assertion failed: unexpected result when testing sed_expression." >&2
          echo "Expected result: ${expecteds[i]}"
          return 1
        fi
      done

      # Add the file

      tar --append -vf $amd64_d_archive --transform "$sed_expression" "$source_file"
    env:
      source_file: ${{ inputs.file-path }}
      directory_in_archive: ${{ steps.safe-paths.outputs.in_archive_location }} # directory within the archive's filesystem, ending with a slash
      non_gzip_archive: ${{ steps.where-archive.outputs.path }}

  - name: Rezip the archive, return to original location
    if: ${{ inputs.is-gzip-compressed }}
    id: rezip-archive
    shell: bash
    run: |
      ## Rezip the archive, return to original location
      cat $decompressed_path | gzip > $original_archive_path
    env:
      original_archive_path: ${{ inputs.archive-path }}
      decompressed_path: ${{ steps.unzip-archive.outputs.decompressed_path }}

  - name: Asserts
    shell: bash
    run: |
      ## Asserts

      echo "Checking our output file (provided at path $archive_path)"
      
      # Assert that we changed the size of our archive
      echo "Note: if archive is gzipped, size increase of archive may be smaller than size of added file."
      final_archive_size_1K="$(du --block-size=1K $archive_path | cut -f1)"
      echo "Size of original archive: ${original_archive_size_1K} K"
      echo "Size of added file: ${expected_size_increase_1K} K"
      echo "New archive size: ${final_archive_size_1K} K"

      if [ "$final_archive_size_1K" -le "$original_archive_size_1K" ]; then
        echo "Assertion failed: new archive is not larger than old archive" >&2
        exit 1
      fi

      # Assert that we created a valid archive
      if [[ $output_is_gzipped == 'true' ]]; then
        echo "Checking if our output is a valid gzipped tar archive..."
        tar -xz --to-stdout -f $archive_path >> /dev/null
        echo "Success"
      else
        echo "Checking if our output is a valid tar archive..."
        tar -x --to-stdout -f $archive_path >> /dev/null
        echo "Success"
      fi
    env:
      output_is_gzipped: ${{ inputs.is-gzip-compressed }}
      # make sure these were calculated with --block-size=1K.
      original_archive_size_1K: ${{ steps.pre-assert.outputs.archive_size }}
      expected_size_increase_1K: ${{ steps.pre-assert.outputs.additions_size }}
      # make sure this matches the expression which defines the action's output.
      archive_path: ${{ inputs.archive-path }}
